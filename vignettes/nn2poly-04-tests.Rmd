---
title: "nn2poly-04-testing_the_implementation_with_generated_data"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{nn2poly-04-testing_the_implementation_with_generated_data}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---




```r
library(nn2poly)
library(keras)
library(tensorflow)
```

This vignette contains several usecases of the `nn2poly` package applied to some precomputed examples that allow us to test special situations and control the behavior of the NN2Poly algorithm.

## Example 0


```r

  nn2poly_example <- nn2poly_example0  

  # Get the needed data
  weights_list <- nn2poly_example$weights_list
  af_string_list <- nn2poly_example$af_string_list
  af_derivatives_list <- nn2poly_example$af_derivatives_list
  q_taylor_vector <- nn2poly_example$q_taylor_vector

  result <- nn2poly_algorithm(
    weights_list = weights_list,
    af_string_list = af_string_list,
    q_taylor_vector = q_taylor_vector,
    store_coeffs = TRUE
  )
#> [1] "partitions obtained"

  # Comparamos el potencial en la segunda capa para neurona 1
  # Note that in new, 2 denotes neuron 1 as 1  are the labels
  print("Potential u at layer 2, neuron 1")
#> [1] "Potential u at layer 2, neuron 1"
  print(result[[3]][[2]])
#> [1] 3.636294 1.500000 1.500000 0.250000 0.500000 0.250000

  print("Output y at layer 2, neuron 1")
#> [1] "Output y at layer 2, neuron 1"
  print(result[[4]][[1]][4])
#> [[1]]
#> [1] 1 1
  print(result[[4]][[2]][4])
#> [1] 0.6335183

  print(1/2*result[[3]][[2]][4]+1/8*result[[3]][[2]][2]^2+
          1/4*result[[3]][[2]][1]*result[[3]][[2]][4])
#> [1] 0.6335184

  0.633518334
#> [1] 0.6335183
```



## Example 1


```r

  nn2poly_example <- nn2poly_example1

  # Get the needed data
  weights_list <- nn2poly_example$weights_list
  af_string_list <- nn2poly_example$af_string_list
  af_derivatives_list <- nn2poly_example$af_derivatives_list
  q_taylor_vector <- nn2poly_example$q_taylor_vector
  test_y <- nn2poly_example$test_y
  test_x <- nn2poly_example$test_x

  result <- nn2poly_algorithm(
    weights_list = weights_list,
    af_string_list = af_string_list,
    q_taylor_vector = q_taylor_vector,
    store_coeffs = TRUE
  )
#> [1] "partitions obtained"

  labels <- result[[length(historical_coeffs)]][[1]]
  coeffs <- result[[length(historical_coeffs)]][[2]]
  
  # Obtain the predicted values for the test data with our Polynomial Regression
  n_test <- length(test_y)
  prediction_PR <- rep(0, n_test)
  
  for (i in 1:n_test) {
    prediction_PR[i] <- eval_poly(test_x, labels = labels, coeffs = coeffs)
  }
  
  # FALTA AÃ‘ADIR LA NN A LOS DATA PARA PODER USAR PREDICT
  
  # Obtain the predicted values with the NN to compare them
  prediction_NN <- predict(nn, test_x)
#> Error in py_call_impl(callable, dots$args, dots$keywords): RuntimeError: in user code:
#> 
#>     C:\Users\pablo\AppData\Local\R-MINI~1\envs\R-RETI~1\lib\site-packages\keras\engine\training.py:1586 predict_function  *
#>         return step_function(self, iterator)
#>     C:\Users\pablo\Documents\R\win-library\4.1\reticulate\python\rpytools\call.py:21 python_function  *
#>         raise RuntimeError(res[kErrorKey])
#> 
#>     RuntimeError: Evaluation error: ValueError: Dimensions must be equal, but are 2 and 13 for '{{node sequential_1/layer__combined__l2/MatMul}} = MatMul[T=DT_FLOAT, transpose_a=false, transpose_b=false](IteratorGetNext, sequential_1/layer__combined__l2/strided_slice_1)' with input shapes: [?,2], [13,40]..

  plot_NN_PR_comparison(prediction_PR, prediction_NN)
#> Error in data.frame(prediction_PR = prediction_PR, prediction_NN = prediction_NN): arguments imply differing number of rows: 100, 102
```


